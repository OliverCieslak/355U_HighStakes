#include <random>
#include <algorithm>
#include "particle.hpp"

// Add a static counter for unique IDs
static unsigned int next_particle_id = 0;

ParticleFilter::ParticleFilter(size_t num_particles, const std::vector<SensorMount>& sensorMounts) 
    : sensors(sensorMounts), 
      numParticles(num_particles),
      lastOdomPosition(0, 0, 0),
      bestParticle(next_particle_id++, lemlib::Pose(0, 0, 0), 0.0) {
    particles.reserve(numParticles);
    
    // Initialize sensor reading buffers
    sensorReadingsBuffer.resize(sensors.size(), std::vector<double>(READING_BUFFER_SIZE, MAX_RANGE_MM));
    bufferIndices.resize(sensors.size(), 0);
}

lemlib::Pose ParticleFilter::generateNoisyPose(const lemlib::Pose& reference, 
                                              double positionNoise, 
                                              double angleNoise,
                                              std::mt19937& gen) {
    std::normal_distribution<> poseDist(0, std::sqrt(positionNoise));
    std::normal_distribution<> angleDist(0, angleNoise);

    double randomAngleDelta = angleDist(gen);
    
    return lemlib::Pose(
        reference.x + poseDist(gen),
        reference.y + poseDist(gen),
        normalizeAngle(reference.theta + randomAngleDelta)
    );
}

void ParticleFilter::initialize(const lemlib::Pose& startPose, lemlib::Chassis* chassis, 
                              double positionNoise, double angleNoise) {
    this->chassis = chassis;
    lastOdomPosition = startPose;
    particles.clear();
    bestParticle = Particle(next_particle_id++, startPose, 1.0);
    
    // Reset all sensor reading buffers to max range
    for (size_t i = 0; i < sensors.size(); i++) {
        std::fill(sensorReadingsBuffer[i].begin(), sensorReadingsBuffer[i].end(), MAX_RANGE_MM);
        bufferIndices[i] = 0;
    }
    
    std::random_device rd;
    std::mt19937 gen(rd());
    
    particles.reserve(numParticles);
    for (size_t i = 0; i < numParticles; i++) {
        particles.emplace_back(
            next_particle_id++,
            generateNoisyPose(startPose, positionNoise, angleNoise, gen),
            1.0 / numParticles  // Maintain uniform initial weights
        );
    }
    initialized = true;

    lastUpdateTime = pros::millis();
}

void ParticleFilter::update(const lemlib::Pose& newOdomPosition) {
    lemlib::Pose odomDelta = newOdomPosition - lastOdomPosition;
    
    // Calculate time delta
    uint32_t currentTime = pros::millis();
    double dt = (currentTime - lastUpdateTime);
    if (dt <= 0) dt = 0.01;
    
    // Calculate linear and angular velocities
    double linearVelocity = std::hypot(odomDelta.x, odomDelta.y) / (dt / 1000.0);
    double angularVelocity = std::abs(odomDelta.theta) / (dt / 1000.0);
    
    // Adjust noise parameters for higher speeds
    double posNoise = 0.005 + 0.1 * std::abs(linearVelocity);
    //double angleNoise = 0.005 + 0.1 * std::abs(angularVelocity);
    double angleNoise = .1 * lemlib::degToRad(5);
    
    std::random_device rd;
    std::mt19937 gen(rd());
    std::normal_distribution<> noise_xy(0, posNoise);
    std::normal_distribution<> noise_theta(0, angleNoise);

    for (auto& particle : particles) {
        if(particle.id == 2) {
            std::cout << "Ori particle Pose: " << particle.id << " (" << particle.pose.x << ", " << particle.pose.y << ", " << (int)(lemlib::radToDeg(particle.pose.theta)) << ")\n";
        }
        particle.pose = particle.pose + odomDelta;
        if(particle.id == 2) {
            std::cout << "Odom Delta Pose: " << particle.id << " (" << particle.pose.x << ", " << particle.pose.y << ", " << (int)(lemlib::radToDeg(particle.pose.theta)) << ")\n";
        }
        
        // Add noise based on updated parameters
        double randomAngleDelta = noise_theta(gen);
        particle.pose.x += noise_xy(gen);
        particle.pose.y += noise_xy(gen);
        particle.pose.theta = normalizeAngle(particle.pose.theta + randomAngleDelta);
        if(particle.id == 2) {
            std::cout << "New particle Pose: " << particle.id << " (" << particle.pose.x << ", " << particle.pose.y << ", " << (int)(lemlib::radToDeg(particle.pose.theta)) << " " << angleNoise << " " << randomAngleDelta << ")\n";
        }
    }
    
    // Update stored values for next iteration
    lastOdomPosition = newOdomPosition;
    lastUpdateTime = currentTime;
}

double ParticleFilter::getExpectedWallDistance(const lemlib::Pose& sensorPose) const {
    const double left = -FIELD_SIZE/2;   // Field boundaries in inches
    const double right = FIELD_SIZE/2;
    const double bottom = -FIELD_SIZE/2;
    const double top = FIELD_SIZE/2;
    
    const std::array<std::array<double,4>,4> walls = {{
        {left, bottom, left, top},    // Left wall
        {right, bottom, right, top},  // Right wall
        {left, bottom, right, bottom},// Bottom wall
        {left, top, right, top}      // Top wall
    }};
    
    double px = sensorPose.x;  // Position is already in inches
    double py = sensorPose.y;
    
    // Use sensor angle directly (VEX uses counter-clockwise positive)
    double dx = std::cos(sensorPose.theta);
    double dy = std::sin(sensorPose.theta);
    
    double minDist = MAX_RANGE_MM;  // Start with max range in mm
    
    for (const auto& wall : walls) {
        // Wall line segment points (all in inches)
        double x1 = wall[0], y1 = wall[1];
        double x2 = wall[2], y2 = wall[3];
        
        // Calculate intersection using parametric equations
        double denom = (dx * (y2 - y1)) - (dy * (x2 - x1));
        if (std::abs(denom) < 1e-6) continue;  // Lines are parallel
        
        double ua = ((x2 - x1) * (py - y1) - (y2 - y1) * (px - x1)) / denom;
        double ub = (dx * (py - y1) - dy * (px - x1)) / denom;
        
        // Check if intersection is valid (on wall segment and in front of sensor)
        if (ua >= 0 && ub >= 0 && ub <= 1) {
            double ix = px + ua * dx;  // Intersection x (in inches)
            double iy = py + ua * dy;  // Intersection y (in inches)
            
            // Calculate actual distance in inches then convert to mm
            double dist = std::hypot(ix - px, iy - py) * 25.4;  // Convert inches to mm
            if (dist < minDist) {
                minDist = dist;
            }
        }
    }
    
    return minDist;  // Return distance in mm directly
}

void ParticleFilter::addReading(size_t sensorIndex, double reading) {
    sensorReadingsBuffer[sensorIndex][bufferIndices[sensorIndex]] = reading;
    bufferIndices[sensorIndex] = (bufferIndices[sensorIndex] + 1) % READING_BUFFER_SIZE;
}

double ParticleFilter::getSmoothedReading(size_t sensorIndex) const {
    const auto& readings = sensorReadingsBuffer[sensorIndex];
    double sum = 0;
    
    // Simple average of all readings in buffer
    for (double reading : readings) {
        sum += reading;
    }
    
    return sum / READING_BUFFER_SIZE;
}

void ParticleFilter::measurementUpdate() {
    std::vector<double> smoothedReadings;
    smoothedReadings.reserve(sensors.size());
    
    for (size_t i = 0; i < sensors.size(); i++) {
        int currentReading = sensors[i].sensor->get();
        // Ignore invalid readings
        if (currentReading < MIN_RANGE_MM || currentReading > MAX_RANGE_MM) {
            continue;
        }
        smoothedReadings.push_back(currentReading);
    }

    // Skip update if no valid readings
    if (smoothedReadings.empty()) return;

    double maxWeight = -1;
    double sumWeights = 0;
    cumulativeWeights.clear();
    cumulativeWeights.reserve(particles.size());
    
    const double MIN_PROBABILITY = 0.1;  // Add minimum probability floor
    
    for (auto& particle : particles) {
        particle.weight = 1.0;
        int validMeasurements = 0;
        
        for (size_t i = 0; i < sensors.size(); i++) {
            double actualDistance_mm = smoothedReadings[i];
            if (actualDistance_mm <= MIN_RANGE_MM) continue;
            if (actualDistance_mm > MAX_RANGE_MM) continue;

            // Calculate sensor's world position
            double sensorTheta = sensors[i].relativePose.theta;
            double rotatedX = sensors[i].relativePose.x * std::cos(sensorTheta) - 
                            sensors[i].relativePose.y * std::sin(sensorTheta);
            double rotatedY = sensors[i].relativePose.x * std::sin(sensorTheta) + 
                            sensors[i].relativePose.y * std::cos(sensorTheta);
            
            lemlib::Pose sensorWorldPose(
                particle.pose.x + rotatedX,
                particle.pose.y + rotatedY,
                normalizeAngle(particle.pose.theta + sensorTheta)
            );

            double expectedDistance_mm = getExpectedWallDistance(sensorWorldPose);
            double diff = std::abs(actualDistance_mm - expectedDistance_mm);
            
            // Debugging: Log expected wall distance and particle angle
            /*
            std::cout << "Particle Pose: " << particle.id << " (" << particle.pose.x << ", " << particle.pose.y << ", " << (int)(lemlib::radToDeg(particle.pose.theta)) << ")\n";
            std::cout << "Sensor World Pose: (" << sensorWorldPose.x << ", " << sensorWorldPose.y << ", " << (int)(lemlib::radToDeg(sensorWorldPose.theta)) << ")\n";            std::cout << "Expected Distance: " << expectedDistance_mm << " mm\n";
            std::cout << "Actual Distance: " << actualDistance_mm << " mm\n";
            std::cout << "Difference: " << diff << " mm\n";
            */
            // Use variance based on sensor specifications
            double variance = getSensorVariance(actualDistance_mm);
            
            // Apply Gaussian model with minimum probability
            double probability = std::max(
                MIN_PROBABILITY,
                std::exp(-diff * diff / (2 * variance))
            );
            
            particle.weight *= probability;
            validMeasurements++;
        }
        
        // Adjust weight based on number of valid measurements
        if (validMeasurements > 0) {
            // Take the geometric mean of the probabilities
            particle.weight = std::pow(particle.weight, 1.0 / validMeasurements);
        }
        
        sumWeights += particle.weight;
        cumulativeWeights.push_back(sumWeights);
        
        if (particle.weight > maxWeight) {
            maxWeight = particle.weight;
            bestParticle = particle;
        }
    }

    // Normalize weights
    if (sumWeights > 0) {
        for (auto& p : particles) {
            p.weight /= sumWeights;
        }
        for (auto& c : cumulativeWeights) {
            c /= sumWeights;
        }
    }
}

void ParticleFilter::resample() {
    // Keep more existing particles
    size_t numParticlesToKeep = particles.size() * 0.8;
    
    // Sort particles by weight
    std::sort(particles.begin(), particles.end(), 
              [](const Particle& a, const Particle& b) { return a.weight > b.weight; });
    
    std::vector<Particle> newParticles(particles.begin(), particles.begin() + numParticlesToKeep);
    
    // Calculate sum of kept weights
    double keptWeightsSum = 0;
    for (const auto& p : newParticles) {
        keptWeightsSum += p.weight;
    }
    
    // Add fewer random particles with smaller spread
    std::random_device rd;
    std::mt19937 gen(rd());
    
    size_t numNewParticles = numParticles - numParticlesToKeep;
    double newParticleWeight = (0.001 * keptWeightsSum) / numNewParticles;
    
    for (size_t i = 0; i < numNewParticles; i++) {
        newParticles.emplace_back(
            next_particle_id++, // Assign unique ID
            generateNoisyPose(bestParticle.pose, 2.0, lemlib::degToRad(5), gen), // Reduced spread for heading
            newParticleWeight
        );
    }
    
    // Normalize weights
    double totalWeight = keptWeightsSum + (newParticleWeight * numNewParticles);
    for (auto& p : newParticles) {
        p.weight /= totalWeight;
    }
    
    particles.swap(newParticles);
}

lemlib::Pose ParticleFilter::getEstimatedPose() const {
    if (particles.empty() || bestParticle.weight <= 0) {
        return lastOdomPosition;
    }

    double x_sum = 0;
    double y_sum = 0;
    double sin_sum = 0;
    double cos_sum = 0;
    double weight_sum = 0;

    for (const auto& p : particles) {
        x_sum += p.pose.x * p.weight;
        y_sum += p.pose.y * p.weight;
        sin_sum += std::sin(p.pose.theta) * p.weight;
        cos_sum += std::cos(p.pose.theta) * p.weight;
        weight_sum += p.weight;
    }

    if (weight_sum <= 0) {
        return bestParticle.pose;
    }

    // Calculate weighted average pose
    x_sum /= weight_sum;
    y_sum /= weight_sum;
    sin_sum /= weight_sum;
    cos_sum /= weight_sum;

    // Calculate average angle using atan2 with clockwise-positive convention
    double theta = normalizeAngle(std::atan2(sin_sum, cos_sum));

    return lemlib::Pose(x_sum, y_sum, theta);
}

void ParticleFilter::start() {
    if (filterTask == nullptr && chassis != nullptr) {
        isRunning = true;
        filterTask = new pros::Task([this] {
            while (isRunning) {
                lemlib::update();
                this->update(chassis->getPose());
                this->measurementUpdate();
                this->resample();
                pros::delay(10);
            }
        });
    }
}

void ParticleFilter::stop() {
    isRunning = false;
    if (filterTask != nullptr) {
        delete filterTask;
        filterTask = nullptr;
    }
}

void ParticleFilter::printParticles() const {
    std::cout << "Best Particle Pose: (" 
              << bestParticle.pose.x << ", " 
              << bestParticle.pose.y << ", " 
              << lemlib::radToDeg(bestParticle.pose.theta) << " degrees), "
              << "Weight: " << bestParticle.weight << std::endl;

    for (const auto& particle : particles) {
        std::cout << "Particle ID: " << particle.id 
                  << " Pose: (" 
                  << particle.pose.x << ", " 
                  << particle.pose.y << ", " 
                  << lemlib::radToDeg(particle.pose.theta) << " degrees), "
                  << "Weight: " << particle.weight << std::endl;
    }
}